--------------------------------------------------------------------------------
TODO NOW

    - syntactic extensions should use parsing expressions
        - but should get reference resolution (but should only reference expr)
            + left-recursion elimination

    - grammatical composition
        - SubGrammar: verify and document

    - index allocation should be per-grammar
        - extensions should be registered before root pe
        - extension pe should be created by extension

    - extensions can define syntactic extension
        - declarations: decl <name> <pe> ;
        - expressions: `<name> { <pe> }

        - isolate syntax of clusters in extension?

TODO NOTES

    - state.uncommit + state.discard == state.restore
    - extensibility on two axis: new combinators + custom state

    - parsec choice combinator doesn't backtrack unless your use try
        - is explicit backtracking control a good idea? (use <|>)
        - related to cut (although simpler implem)

    - look at parsec etc for error handling
        - probably should have a Error(msg) parsing expression that fails with a message
        - interplay with cutting/limited backtracking? to commit to certain alternatives

TODO DEBUGGER

    - rework package
        - positioning in next and error locator
            - invert locate
                - check locators (done: after, before) |<-
        - integrate own capture info
        - register state tracking custom state
        - why do I have a distinction between ExecutionLocation and spine?

    - bookmarks (shared, synchronized) and history (forked)

    - consider later:
        - make location info class
        - document the "non-inspection" behaviour of beforeLocator

TODO GUMPTION

    - use Array instead of [] for first and children in PE
    - insert $ in Java8 grammar (rule-level only) (-> 544)

TODO FURTHER SMALL

    - allow options in grammar files, namely for root and whitespace spec
      (to be retrieved from GrammarCompiler)

    - well formedness check (ford: WF -- can't loop without consuming)

    - scoped memoization
        - MemoScope
        - ScopedMemo

    - repeating locators (which can locate multiple locations if invoked repeatedly)

    - compact parsing expression printing (not multiline)

    - reorganize imports

    - more common parse state patterns

    - abstract the hierarchical string printing pattern
        (present in different kind of trees for instances)

    - generators for state/input/etc boilerplate

    - separate accessors and groups better or make an understandble parse tree build error

    - grammar compositions

    - move precedence into its own extension

TODO FURTHER BIG

    - tokenizers
        - token PE linked to a tokenizer + type
        - memoization window around position
        - error handling: an error over a token can become "unexpected X"
        - advantage: handles reserved identifiers

        - tokenizer X =
        - how to set the current tokenizer?
            `tokenizer(X)`
        - how to call a token?
            % token_name
        - TokenRef class
        - how to mark an alternative as a token
            %= token_name
            `def_token(X)`
        - how to extend syntax with custom functions
            `function(x)[<string>](<expr>)`
            pexp X = <java method ref>
        - no capture operator
            `nocapture(X)`
        - whitespace operator
            `whitespace`
        - dumb operator
            `fast(X)`
        - remove ^= and %= operators

    - better support for layering with smart tree-building that automatically rewrites trees
      (see notes, p. D5)

    - mini type system for captures? automatic AST classes generation?

    - think about building in validation rules

    - grammar composition
        - we already have subgrammars
        - otherwise, union extensions; and glue grammars: requires path descriptors

    - grammar parameterization

TODO MUCH LATER

    - make dumb expression faster via a backtracking DPDA

    - think about how a parser could be retooled to parse html
      (which is lax in syntax) -> need to define bounding boxes

    - semi-parsing
        - start with per-block error recovery

    - performance metrics to guide optimization
        + automatic memoization JIT'ing?

    - value stack?

    - delayed semantic actions?

--------------------------------------------------------------------------------