PARSER PROVIDER

    ////////////////////////////////////////////////////////////////////////////////////////////////

    private static Tracer tracer = null;

    ////////////////////////////////////////////////////////////////////////////////////////////////

    public static Tracer tracer()
    {
        return tracer;
    }

    public static void setTracer(Tracer tracer)
    {
        TestConfiguration.tracer = tracer;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    public static void treeTrace()
    {
        setTracer(Tracer.treeTracer);
    }

    public static void noTrace()
    {
        setTracer(null);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    public static Parser parser(Source src)
    {
        ParserConfiguration config = new ParserConfiguration();
        config.debug = true;
        config.tracer = tracer;
        return new Parser(src, config);
    }

    public static Parser parser(String src)
    {
        return parser(Source.fromString(src));
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * <p>Each call to {@link ParsingExpression#parse} takes a parse input as parameter.</p>
     *
     * <p>The parse input indicates:</p>
     *
     * <ul>
     * <li>The position at which to attempt the match.</li>
     * <li>The last non-whitespace position preceding the match position (aka "black position").</li>
     * <li>The current precedence level.</li>
     * <li>
     *   Various flags that influence the parser behaviour (see the PIF section of {@link Registry}).
     * </li>
     * <li>The current seeds for left-recursive expressions starting at the current input position.</li>
     * <li>The innermost parent expression that can be cut.</li>
     * </ul>
     *
     * The parse input also has dedicated output fields:
     *
     * <ul>
     * <li>
     *   An instance of {@link ParseOutput} to indicate the outcome of the parse (success/failure and
     *   input consumed).
     * </li>
     * <li>
     *   An instance of {@link ParseResult} to which the result of captures in sub-expressions should
     *   be attached.
     * </li>
     * </ul>
     *
     * The parse input also keeps track of the number of children of its result instance at creation
     * time. This allows discarding newer captures if we have to backtrack.
     *
     * <hr/>
     *
     * <p>Excepted for the output fields, most fields should have identical content before and after
     * passing the parse input to {@link ParsingExpression#parse}. It is allowable to change the fields
     * during the call, but they need to be restored to their initial values before completing the
     * call.</p>
     *
     * <p>The only exception is {+@link #parentCuttable}, which indicates the innermost parent
     * expression
     * that can be cut. Since, by definition, a cut inhibits backtracking, undoing its effects is
     * tricky and generally not needed. One can use {+@link #isolateCuts()} in order to prevent a
     * sub-expression from cutting parent expressions. Note that {+@link #isolateCuts()} does modify
     * the value of {+@link #parentCuttable}.</p>
     *
     * <hr/>
     *
     * <h2>Usage</h2>
     *
     * <p>Each call to {@link ParsingExpression#parse} must ensure that {@link #output} reflects the
     * effect of parsing the expression. {@link #output} is initialized with the same position as the
     * input; so expressions that succeed without consuming any input need not touch anything.</p>
     *
     * <p>The most common ways to set the output are to call {@link Parser#fail} (*), {@link
     * ParseOutput#become} (to reuse the outcome of a sub-expression) or {+@link #load} (to reuse the
     * outcome of a saved parse result).</p>
     *
     * <p>(*) {@link Parser#fail} *must* be called in case of failure unless the expression invokes a
     * single sub-expression and inherits its output. This method ensures that captures attached
     * in failed expressions are discarded. It is also necessary to call if errors are to be recorded
     * on the expression.</p>
     *
     * <p>There are two common usage patterns regarding parse inputs in use within {@link
     * ParsingExpression#parse} implementations.</p>
     *
     * <p>The first pattern is to pass the parse input received from the parent directly to the
     * sub-expressions. This is a good choice for expressions with a single sub-expression, or
     * expressions that invoke all their sub-expressions at the same input position (in which case
     * care must be taken to reset the output with {@link #resetOutput} before invoking another
     * expression). You might also find {@link #resetResultChildren} handy.</p>
     *
     * <p>The second pattern is to create a new parse input with the old parse input as parent. This new
     * parse input will mostly inherit the parents fields, but can be modified more freely. This is a
     * good choice for expressions that call their sub-expressions sequentially on the input. In
     * those cases, {@link #advance} is used to update the parse input between sub-expression
     * invocations.</p>
     */