// - Originally from Mouse's Java 7 grammar.
// - Escaped stray backslashes in a few locations ([+\-]); as well as unescaped
//   quotes (in char classes in StringLiteral and Escape).
// - Marked a bunch of places as tokens (:=) and removed leading spacing.

//=========================================================================
//  Compilation
//=========================================================================

Compilation
    = CompilationUnit SUB? EOT;

//=========================================================================
//  JLS 3  Lexical Structure
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 3.1-3  Unicode
//-------------------------------------------------------------------------
//  The Unicode escapes in Java source are converted
//  to Java characters by a preprocessor prior to parsing.
//  This is not emulated here; the Unicode escapes are only allowed
//  in string and character literals. They are treated as error in other
//  structures (except comments). The warning in JLS 3.10.5 against using
//  Unicode escapes for line terminators and quotes in string and character
//  literals does not apply here.
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//  JLS 3.5  Input Elements and Tokens
//-------------------------------------------------------------------------

SUB = "\u001a" ; // Ctrl + Z
EOT = !_ ;

//-------------------------------------------------------------------------
//  JLS 3.6-7  Spacing
//-------------------------------------------------------------------------

Spacing
    = ( [ \t\r\n\f]+      // WhiteSpace
      / "/*" _ *+ "*/"     // TraditionalComment
      / "//" _ *+ [\r\n]   // EndOfLineComment
      )* ;

//-------------------------------------------------------------------------
//  JLS 3.8  Identifiers
//-------------------------------------------------------------------------

Identifier !:= !Keyword Letter LetterOrDigit* ;

Letter = [a-z] / [A-Z] / [_$] ;

LetterOrDigit = [a-z] / [A-Z] / [0-9] / [_$] ;

// These are traditional definitions of letters and digits.
// JLS defines letters and digits as Unicode characters recognized
// as such by special Java procedures, which is difficult
// to express in terms of Parsing Expressions.

//-------------------------------------------------------------------------
//  JLS 3.9  Keywords
//  More precisely: reserved words. According to JLS, "true", "false",
//  and "null" are technically not keywords - but still must not appear
//  as identifiers. Keywords "const" and "goto" are not used; JLS explains
//  the reason.
//-------------------------------------------------------------------------

Keyword
    = ( "abstract"
      / "assert"
      / "boolean"
      / "break"
      / "byte"
      / "case"
      / "catch"
      / "char"
      / "class"
      / "const"
      / "continue"
      / "default"
      / "double"
      / "do"
      / "else"
      / "enum"
      / "extends"
      / "false"
      / "finally"
      / "final"
      / "float"
      / "for"
      / "goto"
      / "if"
      / "implements"
      / "import"
      / "interface"
      / "int"
      / "instanceof"
      / "long"
      / "native"
      / "new"
      / "null"
      / "package"
      / "private"
      / "protected"
      / "public"
      / "return"
      / "short"
      / "static"
      / "strictfp"
      / "super"
      / "switch"
      / "synchronized"
      / "this"
      / "throws"
      / "throw"
      / "transient"
      / "true"
      / "try"
      / "void"
      / "volatile"
      / "while"
      ) !LetterOrDigit
    ;

ABSTRACT     !:= "abstract"     !LetterOrDigit  ;
ASSERT       !:= "assert"       !LetterOrDigit  ;
BOOLEAN      !:= "boolean"      !LetterOrDigit  ;
BREAK        !:= "break"        !LetterOrDigit  ;
BYTE         !:= "byte"         !LetterOrDigit  ;
CASE         !:= "case"         !LetterOrDigit  ;
CATCH        !:= "catch"        !LetterOrDigit  ;
CHAR         !:= "char"         !LetterOrDigit  ;
CLASS        !:= "class"        !LetterOrDigit  ;
CONTINUE     !:= "continue"     !LetterOrDigit  ;
DEFAULT      !:= "default"      !LetterOrDigit  ;
DOUBLE       !:= "double"       !LetterOrDigit  ;
DO           !:= "do"           !LetterOrDigit  ;
ELSE         !:= "else"         !LetterOrDigit  ;
ENUM         !:= "enum"         !LetterOrDigit  ;
EXTENDS      !:= "extends"      !LetterOrDigit  ;
FALSE        !:= "false"        !LetterOrDigit  ;
FINALLY      !:= "finally"      !LetterOrDigit  ;
FINAL        !:= "final"        !LetterOrDigit  ;
FLOAT        !:= "float"        !LetterOrDigit  ;
FOR          !:= "for"          !LetterOrDigit  ;
IF           !:= "if"           !LetterOrDigit  ;
IMPLEMENTS   !:= "implements"   !LetterOrDigit  ;
IMPORT       !:= "import"       !LetterOrDigit  ;
INTERFACE    !:= "interface"    !LetterOrDigit  ;
INT          !:= "int"          !LetterOrDigit  ;
INSTANCEOF   !:= "instanceof"   !LetterOrDigit  ;
LONG         !:= "long"         !LetterOrDigit  ;
NATIVE       !:= "native"       !LetterOrDigit  ;
NEW          !:= "new"          !LetterOrDigit  ;
NULL         !:= "null"         !LetterOrDigit  ;
PACKAGE      !:= "package"      !LetterOrDigit  ;
PRIVATE      !:= "private"      !LetterOrDigit  ;
PROTECTED    !:= "protected"    !LetterOrDigit  ;
PUBLIC       !:= "public"       !LetterOrDigit  ;
RETURN       !:= "return"       !LetterOrDigit  ;
SHORT        !:= "short"        !LetterOrDigit  ;
STATIC       !:= "static"       !LetterOrDigit  ;
STRICTFP     !:= "strictfp"     !LetterOrDigit  ;
SUPER        !:= "super"        !LetterOrDigit  ;
SWITCH       !:= "switch"       !LetterOrDigit  ;
SYNCHRONIZED !:= "synchronized" !LetterOrDigit  ;
THIS         !:= "this"         !LetterOrDigit  ;
THROWS       !:= "throws"       !LetterOrDigit  ;
THROW        !:= "throw"        !LetterOrDigit  ;
TRANSIENT    !:= "transient"    !LetterOrDigit  ;
TRUE         !:= "true"         !LetterOrDigit  ;
TRY          !:= "try"          !LetterOrDigit  ;
VOID         !:= "void"         !LetterOrDigit  ;
VOLATILE     !:= "volatile"     !LetterOrDigit  ;
WHILE        !:= "while"        !LetterOrDigit  ;

//-------------------------------------------------------------------------
//  JLS 3.10  Literals
//-------------------------------------------------------------------------

Literal
    = FloatLiteral      : floatLiteral
    / IntegerLiteral    : integerLiteral    // May be a prefix of FloatLiteral
    / BooleanLiteral    : booleanLiteral
    / CharLiteral       : charLiteral
    / StringLiteral     : stringLiteral
    / NullLiteral       : nullLiteral
    ;

//-------------------------------------------------------------------------
//  JLS 3.10.1  Integer Literals
//-------------------------------------------------------------------------

IntegerLiteral
    !:= ( HexNumeral
      / BinaryNumeral
      / OctalNumeral            // May be a prefix of HexNumeral or BinaryNumeral
      / DecimalNumeral          // May be a prefix of OctalNumeral
      ) [lL]?
    ;

DecimalNumeral
    = "0"
    / [1-9]([_]*[0-9])*
    ;

HexNumeral
    = ("0x" / "0X") HexDigits ;

OctalNumeral
    = "0" ([_]*[0-7])+ ;

BinaryNumeral
    = ("0b" / "0B") [01]([_]*[01])* ;

//-------------------------------------------------------------------------
//  JLS 3.10.2  Floatng-point Literals
//-------------------------------------------------------------------------

FloatLiteral
    !:= ( HexadecimalFloatingPointLiteral
      / DecimalFloatingPointLiteral   // May be a prefix of above
      )
    ;

DecimalFloatingPointLiteral
    = Digits "." Digits?  Exponent? [fFdD]?
    / "." Digits Exponent? [fFdD]?
    / Digits Exponent [fFdD]?
    / Digits Exponent? [fFdD]
    ;

Exponent
    = [eE] [+\\-]? Digits ;

HexadecimalFloatingPointLiteral
    = HexSignificand BinaryExponent [fFdD]? ;

HexSignificand
    = ("0x" / "0X") HexDigits? "." HexDigits
    / HexNumeral "."?                           // May be a prefix of above
    ;

HexDigits
    = HexDigit ([_]*HexDigit)* ;

HexDigit
    = [a-f] / [A-F] / [0-9] ;

BinaryExponent
    = [pP] [+\\-]? Digits ;

Digits
    = [0-9]([_]*[0-9])* ;

//-------------------------------------------------------------------------
//  JLS 3.10.3  Boolean Literals
//-------------------------------------------------------------------------

BooleanLiteral
    = TRUE
    / FALSE
    ;

//-------------------------------------------------------------------------
//  JLS 3.10.4  Character Literals
//-------------------------------------------------------------------------

CharLiteral
    !:= "'" (Escape / !['\\\n\r] _) "'"
    ;

//-------------------------------------------------------------------------
//  JLS 3.10.5 String Literals
//-------------------------------------------------------------------------

StringLiteral
    !:= "\"" (Escape / ![\"\\\n\r] _)* "\""
    ;

Escape
    = "\\" ([btnfr\"'\\] / OctalEscape / UnicodeEscape)
    ;

OctalEscape
    = [0-3][0-7][0-7]
    / [0-7][0-7]
    / [0-7]
    ;

UnicodeEscape
    = "u"+ HexDigit HexDigit HexDigit HexDigit ;

//-------------------------------------------------------------------------
//  JLS 3.10.6 The Null literal
//-------------------------------------------------------------------------

NullLiteral = NULL ;

//-------------------------------------------------------------------------
//  JLS 3.11  Separators
//-------------------------------------------------------------------------

'@'    :=   "@"        ;
'::'   :=   "::"       ;
','    :=   ","        ;
'.'    :=   "."        ;
'...'  :=   "..."      ;
'('    :=   "("        ;
'['    :=   "["        ;
']'    :=   "]"        ;
')'    :=   ")"        ;
'{'    :=   "{"        ;
'}'    :=   "}"        ;
';'    :=   ";"        ;

//-------------------------------------------------------------------------
//  JLS 3.12  Operators
//  The operators < and > is defined uder two names:
//  LT and GT, respectively LPOINT and RPOINT.
//  The last two are used in the type context, to emulate the translation
//  rule given in JLS 3.2.
//-------------------------------------------------------------------------

AND             :=   "&" ![=&]   ;
ANDAND          :=   "&&"        ;
ANDEQU          :=   "&="        ;
ARROW           :=   "->"        ;
BANG            :=   "!" ![=]    ;
BSR             :=   ">>>" ![=]  ;
BSREQU          :=   ">>>="      ;
COLON           :=   ":" ![:]    ;
DEC             :=   "--"        ;
DIV             :=   "/" ![=]    ;
DIVEQU          :=   "/="        ;
EQU             :=   "=" ![=]    ;
EQUAL           :=   "=="        ;
GE              :=   ">="        ;
GT              :=   ">" ![=>]   ;
HAT             :=   "^" ![=]    ;
HATEQU          :=   "^="        ;
INC             :=   "++"        ;
LE              :=   "<="        ;
LPOINT          :=   "<"         ;
LT              :=   "<" ![=<]   ;
MINUS           :=   "-" ![=\->] ;
MINUSEQU        :=   "-="        ;
MOD             :=   "%" ![=]    ;
MODEQU          :=   "%="        ;
NOTEQUAL        :=   "!="        ;
OR              :=   "|" ![=|]   ;
OREQU           :=   "|="        ;
OROR            :=   "||"        ;
PLUS            :=   "+" ![=+]   ;
PLUSEQU         :=   "+="        ;
QUERY           :=   "?"         ;
RPOINT          :=   ">"         ;
SL              :=   "<<" ![=]   ;
SLEQU           :=   "<<="       ;
SR              :=   ">>" ![=>]  ;
SREQU           :=   ">>="       ;
STAR            :=   "*" ![=]    ;
STAREQU         :=   "*="        ;
TILDE           :=   "~"         ;

//=========================================================================
//  JLS 4  Types, Values and Variables
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 4.2  Primitive Types and Values
//-------------------------------------------------------------------------

/*

basicType (+)

primitiveType
    <basicType>
    <annotations>
*/

BasicType
    = (
      BYTE
    / SHORT
    / INT
    / LONG
    / CHAR
    / FLOAT
    / DOUBLE
    / BOOLEAN
    ) :+ basicType
    ;

PrimitiveType
    = (Annotations BasicType):primitiveType ;

//-------------------------------------------------------------------------
//  JLS 4.3  Reference Types and Values
//-------------------------------------------------------------------------

/*

referenceType
    OR
        <primitiveType>
        <classType>
    <dims>

classType
    <annotations>
    id (+)
    <typeArgs>

dims (*)
    <annotations>

stemType
    <primitiveType>
    <classType>

typeVariable
    <annotations>
    id (+)

type
    OR
        <primitiveType>
        <classType>
    <dims>

exceptionType
    OR
        <classType>
        <typeVariable>

*/

ReferenceType
    = (
      PrimitiveType DimsAlo
    / ClassType     Dims
    ):referenceType
    ;

ClassType
    = ((Annotations Identifier:+id TypeArguments?) :* components ,+ '.'):classType ;

StemType
    = (
      PrimitiveType
    / ClassType
    ):stemType
    ;

Type
    = (( PrimitiveType / ClassType ) Dims):type ;

TypeVariable
    = (Annotations Identifier:+id):typeVariable ;

Dim
    = Annotations '[' ']' ;

Dims
    = Dim :* dims * ;

DimsAlo
    = Dim :* dims + ;

ExceptionType
    = (ClassType / TypeVariable):exceptionType ;

//-------------------------------------------------------------------------
//  JLS 4.4  Type Variables
//-------------------------------------------------------------------------

/*

typeParameter
    <annotations>
    id (+)
    OR?
        boundTypes (#)
            <classType>
        <typeVariable>

*/

TypeParameter
    = (Annotations Identifier:+id TypeBound?):typeParameter ;

TypeBound
    = EXTENDS ((ClassType :# boundTypes) ,+ AND / TypeVariable) ;

//-------------------------------------------------------------------------
//  JLS 4.5  Parametrized Types
//-------------------------------------------------------------------------

/*

typeArgs (#)
    <wildcard>
    <referenceType>

wildcard
    <annotations>
    OR?
        extends
            <referenceType>
        super
            <referenceType>

*/

TypeArguments
    = LPOINT TypeArgument:#typeArgs ,+ ',' RPOINT ;

TypeArgument
    = ReferenceType
    / Wildcard
    ;

Wildcard
    = (Annotations QUERY WildcardBounds?):wildcard ;

WildcardBounds
    = EXTENDS ReferenceType:extends
    / SUPER ReferenceType:super
    ;

//=========================================================================
//  JLS 6  Names
//=========================================================================

QualIdent
    = Identifier ,+ '.';

//=========================================================================
//  JLS 7  Packages
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 7.3  Compilation Units
//-------------------------------------------------------------------------

/*

<root>
    <package>
    imports (#)
        <import>
    types (*)
        <typeDeclaration>

*/

CompilationUnit
    = PackageDeclaration? (ImportDeclaration :# imports)* (TypeDeclaration :* types)* ;

//-------------------------------------------------------------------------
//  JLS 7.4  Package Declarations
//-------------------------------------------------------------------------

/*

package
    <annotations>
    name (+)

*/

PackageDeclaration
    = (Annotations PACKAGE QualIdent:+name):package ';' ;

//-------------------------------------------------------------------------
//  JLS 7.5  Import Declarations
//-------------------------------------------------------------------------

/*

import
    static (?)
    id (+)
    star (?)

*/

ImportDeclaration
    = (IMPORT STATIC:static? QualIdent:+id ('.' STAR:star)?):import ';'
    / ';'
    ;

//=========================================================================
//  JLS 8  Classes
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 8.1  Class Declarations & 8.9 Enum Declaration & 9.6 Annotation Type
//-------------------------------------------------------------------------

/*

NOTE: interfaces can't be final (& more constraints)

<typeModifiers>
    modifiers (#)
        <annotation>
        public
        protected
        private
        abstract
        static
        final
        strictfp

typeParameters (#)
    <typeParameter>

typeDeclaration
    <typeModifiers>
    annotationDeclaration (?)
    OR
        class
        enum
        interface
    id
    <typeParameters> (?)
    extends (#) (?)
        <classType>
    implements (#) (?)
        <classType>
    enumConstants (*) (?)
        <annotations>
        id (+)
        <arguments>
    <declarations>

declarations (#)
    <fieldDeclaration>
    <methodDeclaration>
    <typeDeclaration>
    <annotationElemDecl>
    <statements>
    static
        <statements>
    <constructorDeclaration>
    semi

annotationElemDecl
    modifiers (#)
        <annotation>
        public
        abstract
    <type>
    id (+)
    <dims>
    <annotationValue> (?)

*/

// NOTE: enums can't have superclasses or type params, and regular classe can't have enum constants
// NOTE: annotation types can't have supertypes or type parameters
// NOTE: interfaces must "extends" other interfaces

TypeDeclaration
    = TypeModifiers (EnumDeclaration / OtherTypeDeclaration) ;

EnumDeclaration
    = ENUM:enum
      Identifier:+id
      Extends?
      Implements?
      '{' (EnumConstant :* enumConstants) , ',' ','? (';' ClassBodyDeclarations)? '}' ;

OtherTypeDeclaration
    = (CLASS:class / ENUM:enum / '@':annotationDeclaration? INTERFACE:interface)
      Identifier:+id
      TypeParameters?
      Extends?
      Implements?
      ClassBody ;

Extends
    = EXTENDS (ClassType ,+ ',') :# extended ;

Implements
    = IMPLEMENTS (ClassType ,+ ',') :# implemented ;

TypeModifiers
    = (
      Annotation
    / PUBLIC:public
    / PROTECTED:protected
    / PRIVATE:private
    / ABSTRACT:abstract
    / STATIC:static
    / FINAL:final
    / STRICTFP:strictfp
    ) :# modifiers *
    ;

TypeParameters
    = LPOINT TypeParameter :# typeParameters ,+ ',' RPOINT ;

ClassBody
    = '{' ClassBodyDeclarations '}' ;

ClassBodyDeclarations
    = ClassBodyDeclaration :# declarations * ;

// NOTE: interface have severe restrictions on these!
//       methods (ofc), visibility, everything implicitly static, sometimes final, etc

// NOTE: idem for annotation types (only constant fields + element)
//       of course elements are only valid for annotations types

ClassBodyDeclaration
    = FieldDeclaration
    / MethodDeclaration
    / TypeDeclaration
    / AnnotationTypeElementDeclaration

    /** end members, start other declarations **/

    / Block
    / (STATIC Block):static
    / ConstructorDeclaration
    / ';':semi
    ;

EnumConstant
    = Annotations Identifier:+id Arguments? ClassBody? ;

AnnotationTypeElementDeclaration
    = AnnotationTypeElementModifiers Type Identifier:+id '(' ')' Dims
         (DEFAULT ElementValue)? ';' ;

 AnnotationTypeElementModifiers
     = (
       Annotation
     / PUBLIC:public
     / ABSTRACT:abstract
     ) :# modifiers *
     ;

//-------------------------------------------------------------------------
//  JLS 8.3  Field Declarations
//-------------------------------------------------------------------------

/*

<fieldModifiers>
    modifiers (#)
        <annotation>
        public
        protected
        private
        static
        final
        transient
        volatile

fieldDeclaration
    <fieldModifiers>
    <type>
    <declarators>

declarators (#)
    <declarator>

declarator
    <declaratorId>
    <variableInitializer> (?)

declaratorId
    id
    <dims>

variableInitializer
    OR
        <expression>
        elementInitializers

*/

FieldDeclaration
    = (FieldModifiers Type VariableDeclaratorList ';'):fieldDeclaration ;

VariableDeclaratorList
    = (VariableDeclarator :# declarators) ,+ ',' ;

VariableDeclarator
    = (VariableDeclaratorId (EQU VariableInitializer)?):declarator ;

VariableDeclaratorId
    = (Identifier:+id Dims):declaratorId ;

VariableInitializer
    = (Expression / ArrayInitializer):variableInitializer ;

FieldModifiers
    = (
      Annotation
    / PUBLIC:public
    / PROTECTED:protected
    / PRIVATE:private
    / STATIC:static
    / FINAL:final
    / TRANSIENT:transient
    / VOLATILE:volatile
    ) :# modifiers *
    ;

UnannClassType
    = Identifier TypeArguments?
          ('.' Annotation* Identifier TypeArguments?)*  ;

UnannType
    = BasicType Dim*
    / UnannClassType Dim*
    ;

//-------------------------------------------------------------------------
//  JLS 8.4  Method Declarations
//-------------------------------------------------------------------------

/*

<variableModifiers>
    modifiers (#)
        <annotation>
        final

<methodModifiers>
    modifiers (#)
        <annotation>
        pulibc
        protected
        private
        abstract
        static
        final
        synchronized
        native
        strictfp

<return>
    OR
        <type>
        void

methodDeclaration
    <methodModifiers>
    <return>
    id (+)
    <parameters>
    <dims>

parameters (*)
    <variableModifiers>
    <type>
    <annotations> (?)
    ellipsis (?)
    <declaratorId>
    <exceptions> (?)
    <statements>

exceptions (#)
    <exceptionType>

*/

MethodDeclaration
    = ( MethodModifiers
        TypeParameters?
        (Type / VOID:void)
        Identifier:+id
        FormalParameters
        Dims
        Throws?
        (Block / ';')
      ) : methodDeclaration ;

// NOTE this does not separate the receiver parameter (where the first param is this; or Type.this
//      where Type is the type of this class / nested class (e.g. pkg.Outer.Inner.this)

// NOTE variadic parameter are only allowed as last parameter!

FormalParameters
    = '(' (FormalParameter :* parameters) , ',' ')' ;

FormalParameter
    = VariableModifiers Type VariableDeclaratorId
    / VariableModifiers Type Annotations '...':ellipsis VariableDeclaratorId !','
    ;

VariableModifiers
    = ( Annotation / FINAL ) :# modifiers * ;

// NOTE: only interface methods can be default (and must be, to have a body)

MethodModifiers
    = (
      Annotation
    / PUBLIC:public
    / PROTECTED:protected
    / PRIVATE:private
    / ABSTRACT:abstract
    / STATIC:static
    / FINAL:final
    / SYNCHRONIZED:synchronized
    / NATIVE:native
    / STRICTFP:strictfp
    / DEFAULT:default
    ) :# modifiers *
    ;

Throws
    = THROWS ExceptionType :# exceptions ,+ ',' ;

//-------------------------------------------------------------------------
//  JLS 8.8  Constructor Declarations
//-------------------------------------------------------------------------

/*

constructorModifiers (#)
    <annotation>
    public
    protected
    private

constructorDeclaration
    <constructorModifiers>
    <typeParameters> (?)
    id (+)
    <parameters>
    <exceptions> (?)
    <constructorInvocation>
    <statements>

constructorInvocation
    <typeArguments> (?)
    enclosingInstance (?)
        <expression>
    OR
        this
        super
    <arguments>

*/

ConstructorDeclaration
    = ConstructorModifier :# constructorModifiers *
      TypeParameters?
      Identifier:+id
      FormalParameters
      Throws?
      '{' ExplicitConstructorInvocation? BlockStatements '}' ;

ConstructorModifier
    = Annotation
    / PUBLIC:public
    / PROTECTED:protected
    / PRIVATE:private
    ;

ExplicitConstructorInvocation
    = TypeArguments? THIS:this Arguments ';'
    / TypeArguments? SUPER:super Arguments ';'

    // http://stackoverflow.com/questions/2831484
    // NOTE: only primary expression allowed here?

    / Expression:enclosingInstance '.' TypeArguments? SUPER:super Arguments ';'
    ;

//=========================================================================
//  JLS 9  Interfaces
//=========================================================================

//-------------------------------------------------------------------------
//  JLS 9.7  Annotations
//-------------------------------------------------------------------------

/*

annotations (#)
    annotation

annotation
    id (+)
    OR (?)
        <annotationValue>
        pairs (*)
            id (+)
            <annotationValue>

<annotationValue>
    value
        OR
            annotation
            expression
            values (#)
                <annotationValue>
*/

Annotations
    = Annotation :# annotations * ;

Annotation
    = ('@' QualIdent:+id ('('( (ElementValuePair :* pairs) ,+ ',' / ElementValue )? ')')?)
      : annotation ;

ElementValuePair
    = Identifier:+id EQU ElementValue ;

ElementValue
    = (
      (Expression forbid { assign }):expression
    / ElementValueArrayInitializer
    / Annotation
    ) : value
    ;

ElementValueArrayInitializer
    = '{' (ElementValue :# values) , ',' ','? '}' ;

//=========================================================================
//  JLS 10  Arrays
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 10.6  Array Initializers
//-------------------------------------------------------------------------

/*

elementInitializers (#)
    <variableInitalizer>

*/

ArrayInitializer
    = '{' (VariableInitializer :# elementInitializers) , ',' ','? '}' ;

//=========================================================================
//  JLS 14  Blocks and Statements
//=========================================================================
//-------------------------------------------------------------------------
//  JLS 14.2 Blocks
//-------------------------------------------------------------------------

/*

statements (#)
    <statement>

*/

Block
    = '{' BlockStatements '}' ;

BlockStatements
    = BlockStatement :# statements * ;

// NOTE: interface / type annotation & enums can't be local

BlockStatement
    = LocalVariableDeclaration ';'
    / TypeDeclaration
    / Statement
    ;

//-------------------------------------------------------------------------
//  JLS 14.4  Local Variable Declaration Statements
//-------------------------------------------------------------------------

/*

localVarDecl
    <variableModifiers>
    <type>
    <declarators>

*/

LocalVariableDeclaration
    = (VariableModifiers Type VariableDeclaratorList):localVarDecl ;

//-------------------------------------------------------------------------
//  JLS 14.5  Statements
//-------------------------------------------------------------------------

/*

<statement>
    OR
        <statements>

        ifElse
            <expression> [condition]
            <statement>  [if]
            <statement>  [else]

        <basicFor>

        <enhancedFor>

        while
            <expression> [condition]
            <statement>  [body]

        doWhile
            <expression> [condition]
            <statement>  [body]

        <try>

        switch
            <expression>
            switchBlocks (*)
                labels (#)
                    label (+)
                    default
                <statements>

        synchronized
            <expression>
            <statements>

        return
            <expression> (?)

        throw
            <expression>

        break
            id (+) (?)

        continue
            id (+) (?)

        assert
            <expression>
            message (?)
                <expression>

        semi

        stmtExpr
            <expression>

        labelled
            label (+)
            <statement>

*/

Statement
    = Block
    / (IF ParExpression Statement (ELSE Statement)?):ifElse
    / BasicForStatement
    / EnhancedForStatement
    / (WHILE ParExpression Statement):while
    / (DO Statement WHILE ParExpression ';'):doWhile
    / TryStatement
    / (SWITCH ParExpression SwitchBlock):switch
    / (SYNCHRONIZED ParExpression Block):synchronized
    / (RETURN Expression?):return ';'
    / (THROW Expression):throw ';'
    / (BREAK Identifier:+id?):break ';'
    / (CONTINUE Identifier:+id?):continue ';'
    / (ASSERT Expression (COLON Expression:message)?):assert ';'
    / ';':semi
    / StatementExpression:stmtExpr ';'
    / (Identifier:+label COLON Statement):labelled
    ;

ParExpression
    = '(' Expression ')' ;

//-------------------------------------------------------------------------
//  JLS 14.11  The SWITCH Statement
//-------------------------------------------------------------------------

SwitchBlock
    = '{' (SwitchLabel :# labels + BlockStatements) :* switchBlocks * '}' ;

SwitchLabel
    = CASE Expression:+label COLON / DEFAULT:default COLON ;

//-------------------------------------------------------------------------
//  JLS 14.14  The FOR Statement
//-------------------------------------------------------------------------

/*

basicFor
    init (?)
        OR
            <localVarDecl>
            <stmtExprs>
    cond (?)
        <expression>

    iter (?)
        <stmtExprs>
    body
        <statement>

stmtExprs (#)
    <expression>

enhancedFor
    <variableModifiers>
    <type>
    <declaratorId>
    iterable
        <expression>
    body
        <statement>

*/

BasicForStatement
    = (FOR '(' ForInit:init? ';' Expression:cond? ';' StatementExpressionList:iter? ')'
            Statement:body):basicFor ;

ForInit
    = LocalVariableDeclaration
    / StatementExpressionList
    ;

StatementExpressionList
    = StatementExpression :# stmtExprs ,+ ',' ;

EnhancedForStatement
    = (FOR '(' VariableModifiers Type VariableDeclaratorId COLON
          Expression:iterable ')' Statement:body):enhancedFor ;

//-------------------------------------------------------------------------
//  JLS 14.20  The TRY Statement
//-------------------------------------------------------------------------

/*

try
    resources (*)
        <variableModifiers>
        <type>
        <declaratorId>
        value
            <expression>
    <statements>
    catchClauses (*)
        <variableModifiers>
        types (#)
            <classType>
        <declaratorId>
        <statements>
    finally
        <statements>
*/

TryStatement
    = (TRY
      ( Block (CatchClause* Finally / CatchClause+)
      / '(' (Resource :* resources) ,+ ';' ';'? ')' Block CatchClause* Finally?
      )):try
    ;

CatchClause
    = (CATCH '(' CatchFormalParameter ')' Block) :* catchClauses ;

CatchFormalParameter
    = VariableModifiers (ClassType :# types) ,+ OR VariableDeclaratorId ;

Finally
    = FINALLY Block:finally ;

Resource
    = VariableModifiers Type VariableDeclaratorId EQU Expression:value ;


//=========================================================================
//  JLS 15  Expressions
//=========================================================================

//-------------------------------------------------------------------------
//  JLS 15.9  Class Instance Creation Expressions
//-------------------------------------------------------------------------

/*

<classCreator>
    <typeArgs> (?)
    <annotations>
    <arguments>
    components (*)
        <annotations>
        id (+)
        OR ?
            <typeArgs>
            diamond
    <declarations>

*/

ClassCreator
    = TypeArguments? Annotations ClassTypeWithDiamond Arguments ClassBody? ;

ClassTypeWithDiamond
    = ((Annotations Identifier:+id TypeArgumentsOrDiamond?) :* components) ,+ '.' ;

TypeArgumentsOrDiamond
    = TypeArguments
    / (LPOINT RPOINT !'.'):diamond  // Must be last
    ;

//-------------------------------------------------------------------------
//  JLS 15.10  Array Creation and Access Expressions
//-------------------------------------------------------------------------

/*

<arrayCreator>
    <stemType>
    dimExprs (*) (?)
        <annotations>
        1 [dimExpr]
    <dims>
    <arrayInitializer> (?)

*/

// NOTE: arrays with an initializer cannot have dimension expressions

ArrayCreator
    = StemType DimExpr :* dimExprs + Dims
    / StemType DimsAlo ArrayInitializer
    ;

DimExpr
    = Annotations '[' Expression ']' ;

//-------------------------------------------------------------------------
//  JLS 15.12  Method Invocation Expressions
//-------------------------------------------------------------------------

/*

arguments (#)
    <expression>

*/

Arguments
    = '(' (Expression :# arguments) , ',' ')' ;

//-------------------------------------------------------------------------
//  JLS 15.27  Lambda Expressions
//-------------------------------------------------------------------------

/*

lambda
    OR
        id (+)
        <parameters>
        inferredParameters (*+)
    lambdaBody
        OR
            <expression>
            <statements>

*/

LambdaExpression
    = (LambdaParameters ARROW (Expression / Block):lambdaBody) : lambda ;

LambdaParameters
    = Identifier:+id
    / FormalParameters
    / '(' (Identifier :+* inferredParameters) ,+ ',' ')'
    ;

// ===============================================================================

Expression = expr

    -> Assignment               @+ @left_recur @assign
    -> LambdaExpression         @=
    -> ConditionalExpression    @+ @left_recur

    // BINARY OPERATORS

    -> OrOr                     @+ @left_assoc
    -> AndAnd                   @+ @left_assoc
    -> Or                       @+ @left_assoc
    -> Hat                      @+ @left_assoc
    -> And                      @+ @left_assoc

    -> Equal                    @+ @left_assoc
    -> NotEqual                 @=

    -> Le                       @+ @left_assoc
    -> Ge                       @=
    -> Lt                       @=
    -> Gt                       @=
    -> InstanceOf               @=

    -> Sl                       @+ @left_assoc
    -> Sr                       @=
    -> Bsr                      @=

    -> Plus                     @+ @left_assoc
    -> Minus                    @=

    -> Star                     @+ @left_assoc
    -> Div                      @=
    -> Mod                      @=

    // PREFIX OPERATORS

    -> BInc                     @+ @binc
    -> BDec                     @= @bdec
    -> UPlus                    @=
    -> UMinus                   @=
    -> Tilde                    @=
    -> Bang                     @=
    -> CastExpression           @= // does not conflict with (expr)(arguments) because lower precedence

    // POSTFIX EXPRESSIONS

    -> AInc                     @+ @left_assoc @ainc
    -> ADec                     @= @adec
    -> DotTypeArgs              @= @tmcall
    -> Call                     @= @mcall
    -> DotIden                  @= @dot_iden
    -> DotNew                   @=
    -> DotThis                  @=
    -> DotSuper                 @=
    -> DotClass                 @=
    -> ArrayAccess              @= @array_access
    -> MethodRef                @=
    -> NewRef                   @=

    // POSTFIX TYPES

    -> TypeWithArgs             @=
    -> ArrayType                @=

    // PRIMARY EXPRESSIONS

    -> '(' drop Expression ')'  @+
    -> ThisCall                 @=
    -> THIS:this                @=
    -> SuperCall                @=
    -> SUPER:super              @=
    -> CtorCall                 @= @ccall
    -> ArrayCtorCall            @=
    -> Identifier:+identifier   @= @iden
    -> Literal                  @=

    // PRIMARY TYPES

    -> BasicType    @=
    -> VOID:void    @=
    ;

// ===============================================================================

/*

assignment
    l <expression>
    op (+)
    r <expression>

conditionalExpr
    cond <expression>
    if   <expression>
    else <expression>

cast
    types (#)
        <type>
    op <expression>

*/

Assignment
    = (LValue:l AssignmentOperator:+op Expression:r):assignment ;

LValue
    = Expression allow { iden, dot_iden, array_access } ;

AssignmentOperator
    = EQU
    / STAREQU
    / DIVEQU
    / MODEQU
    / PLUSEQU
    / MINUSEQU
    / SLEQU
    / SREQU
    / BSREQU
    / ANDEQU
    / HATEQU
    / OREQU
    ;

ConditionalExpression
    = (Expression:cond QUERY drop Expression:if COLON Expression:else):conditionalExpr ;

// NOTE: first must be reference type or primitive type
//       further allowed only w/ reference type and must be class types

CastExpression
    = ( '(' (Type :# types) ,+ AND ')' Expression:op ) : cast ;


/*

INFIX:
    l <expression>
    r <expression>

PREFIX
    op <expression>

dotTypeArgs
    op <expression>
    <typeArgs>
    id (+)
    <arguments>

call
    op <expression>
    <arguments>

dotIden
    op <expression>
    id (+)

arrayAccess
    op <expression>
    subscript <expression>

methodRef
    op <expression>
    <typeArguments>
    id (+)

newRef
    op <expression>
    <typeArguments>

typeWithArgs
    op <expression>
    <typeArguments>

OTHER SUFFIX
    op <expression>

thisCall
    <arguments>

superCall
    <arguments>

ctorCall
    <classCreator>

arrayCtorCall
    <arrayCreator>

*/

OrOr        = (Expression:l OROR          Expression:r) : oror          ;
AndAnd      = (Expression:l ANDAND        Expression:r) : andand        ;
Or          = (Expression:l OR            Expression:r) : or            ;
Hat         = (Expression:l HAT           Expression:r) : hat           ;
And         = (Expression:l AND           Expression:r) : and           ;

Equal       = (Expression:l EQUAL         Expression:r) : equal         ;
NotEqual    = (Expression:l NOTEQUAL      Expression:r) : notEqual      ;

Le          = (Expression:l LE            Expression:r) : le            ;
Ge          = (Expression:l GE            Expression:r) : ge            ;
Lt          = (Expression:l LT            Expression:r) : lt            ;
Gt          = (Expression:l GT            Expression:r) : gt            ;
InstanceOf  = (Expression:l INSTANCEOF    Expression:r) : instanceof    ;

Sl          = (Expression:l SL            Expression:r) : sl            ;
Sr          = (Expression:l SR            Expression:r) : sr            ;
Bsr         = (Expression:l BSR           Expression:r) : bsr           ;

Plus        = (Expression:l PLUS          Expression:r) : plus          ;
Minus       = (Expression:l MINUS         Expression:r) : minus         ;

Star        = (Expression:l STAR          Expression:r) : star          ;
Div         = (Expression:l DIV           Expression:r) : div           ;
Mod         = (Expression:l MOD           Expression:r) : mod           ;

BInc        = (INC      Expression:op) : bInc      ;
BDec        = (DEC      Expression:op) : bDec      ;
UPlus       = (PLUS     Expression:op) : uPlus     ;
UMinus      = (MINUS    Expression:op) : uMinus    ;
Tilde       = (TILDE    Expression:op) : tilde     ;
Bang        = (BANG     Expression:op) : bang      ;

AInc        = (Expression:op INC                                                ) : aInc        ;
ADec        = (Expression:op DEC                                                ) : aDec        ;
DotTypeArgs = (Expression:op '.' TypeArguments Identifier:+id drop Arguments    ) : dotTypeArgs ;
Call        = (Expression:op drop Arguments                                     ) : call        ;
DotIden     = (Expression:op '.' Identifier:+id                                 ) : dotIden     ;
DotNew      = (Expression:op '.' NEW drop ClassCreator                          ) : dotNew      ;
DotThis     = (Expression:op '.' THIS                                           ) : dotThis     ;
DotSuper    = (Expression:op '.' SUPER                                          ) : dotSuper    ;
DotClass    = (Expression:op '.' CLASS                                          ) : dotClass    ;
ArrayAccess = (Expression:op '[' drop Expression:subscript ']'                  ) : arrayAccess ;
MethodRef   = (Expression:op '::' TypeArguments? Identifier:+id                 ) : methodRef   ;
NewRef      = (Expression:op '::' TypeArguments? NEW                            ) : newRef      ;

TypeWithArgs = (Expression:op TypeArguments    ) : typeWithArgs    ;
ArrayType    = (Expression:op '[' ']'          ) : arrayTYpe       ;

ThisCall        = (THIS  Arguments          ) : thisCall        ;
SuperCall       = (SUPER Arguments          ) : superCall       ;
CtorCall        = (NEW drop ClassCreator    ) : ctorCall        ;
ArrayCtorCall   = (NEW drop ArrayCreator    ) : arrayCtorCall   ;

// ===============================================================================

StatementExpression
    = Expression allow { assign, binc, bdec, ainc, adec, mcall, tmcall, ccall } ;